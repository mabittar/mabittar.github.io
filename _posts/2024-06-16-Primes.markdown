---
layout: post
title: Calculo de n√∫mero primos
date: 2024-06-16 00:00:00 +0300
description: Otimizando c√°lculo de n√∫meros primos. # Add post description (optional)
img: key.jpg # Add image post (optional)
tags: [Primes, Cryptography] # add tag
---

## Explorando Diferentes Formas de Calcular N√∫meros Primos com Python! üêç

Voc√™ sabia que existem diversas formas de encontrar n√∫meros primos, cada uma com sua pr√≥pria efici√™ncia? Recentemente, explorei algumas abordagens diferentes em Python e foi uma experi√™ncia fascinante. Vamos dar uma olhada nelas?


### Tentativa de Divis√£o (O(n¬≤)): 

Esta √© a abordagem mais b√°sica, onde verificamos cada n√∫mero at√© ùëõ n para ver se √© divis√≠vel apenas por 1 e por ele mesmo
#### Resultados obtidos em 30s:
maior n√∫mero primo: 103837

### Divis√£o Otimizada (O(n‚àön)): 

Melhoramos a primeira abordagem verificando divisores apenas at√© a raiz quadrada de ùëõ n.
#### Resultados obtidos em 30s:
maior n√∫mero primo: 3788747


### One Line

Usa compreens√£o de listas para filtrar divisores, mas √© menos eficiente comparado aos outros m√©todos.
#### Resultados obtidos em 30s:
maior n√∫mero primo: 44530


### Crivo de Erat√≥stenes (O(n log log n)): 

Um m√©todo muito mais eficiente que utiliza uma lista para marcar m√∫ltiplos de cada n√∫mero primo encontrado.
#### Resultados obtidos em 30s:
maior n√∫mero primo: 31742362


Aqui est√° um exemplo do c√≥digo que utilizei para comparar essas abordagens, incluindo uma fun√ß√£o para medir o tempo de execu√ß√£o:


```python
from functools import wraps
import math
from time import perf_counter, time


def timeit(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        s = perf_counter()
        try:
            return func(*args, **kwargs)
        finally:
            elapsed = (perf_counter() - s)
            if elapsed < 1:
                elapsed = elapsed * 1000
                msg = f"{elapsed:0.4f} ms."
            else:
                msg = f"{elapsed:0.4f} s."
            print(f"Method: {func.__name__} executed in {msg}.")

    return wrapper

def trial_division(n):
    if n <= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def optimized_division(n):
    if n <= 1:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

@timeit
def primes_sieve(n):
    prime, sieve = [], set()
    start_time = time()
    q = 2
    while (time() - start_time) < time_limit:
        if q not in sieve:
            prime.append(q)
            sieve.update(range(q*q, q*int(time_limit)+1, q))
        q += 1
    return prime

def one_line(n):
    divisors = [d for d in range(2, n//2+1) if n % d == 0]
    return [d for d in divisors if
            all(d % od != 0 for od in divisors if od != d)]

def find_primes_within_time_limit(time_limit, algorithm):
    primes = []
    start_time = time()
    n = 2
    while (time() - start_time) < time_limit:
        if algorithm(n):
            primes.append(n)
        n += 1
    return primes

def informs(primes):
    print(f'primes found: {len(primes)}')
    print(f'last prime found: {primes[-1]}')
    print(f'largest prime length found is: {len(str(primes[-1]))}')

@timeit
def run_algorithm(time_limit, algorithm, is_sieve=False):
    if is_sieve:
        primes = algorithm(time_limit)
    else:
        primes = find_primes_within_time_limit(time_limit, algorithm)
    informs(primes)
    return primes

if __name__ == '__main__':
    try:
        algorithms = [
            (trial_division, False),
            (one_line, False),
            (optimized_division, False),
            (primes_sieve, True),
        ]
        time_limit = 10  # seconds
        for algo, is_sieve in algorithms:
            run_algorithm(time_limit, algo, is_sieve)
    except Exception as e:
        print(e)
    finally:
        print('Done!')

```


## Sugest√£o de otimiza√ß√£o

Essa foi uma jornada curta, comparada com os outos posts, mas voc√™ teria alguma outra sugest√£o? 

Eu deixo aqui um desafio, implementar o m√©todo segmented sieve: Uma extens√£o do Sieve of Eratosthenes, que divide o intervalo em segmentos para reduzir o uso de mem√≥ria, tornando-o eficiente para encontrar primos em intervalos grandes.



Para ver outros projetos acesse o meu [portfolio de projetos](https://github.com/mabittar/Portfolio).
